<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>OCHO ‚Ä¢ Enhanced Jukebox</title>

  <style>
    :root{ 
      --green:#00ff9a; 
      --blue:#1f6fff; 
      --red:#ff2d2d;
      --dark:#0a0e0d;
    
      --purple:#a855f7; }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--dark);color:#eafff6;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;}
    body{overflow:hidden}

    /* Matrix Rain Background */
    #matrixCanvas{
      position:fixed;
      top:0;left:0;
      width:100%;height:100%;
      opacity:0.15;
      pointer-events:none;
      z-index:1;
    }

    /* Background container */
    .bg{
      position:fixed; inset:0;
      background:
        radial-gradient(1200px 700px at 50% 70%, rgba(0,255,154,.12), transparent 60%),
        radial-gradient(900px 500px at 50% 40%, rgba(0,255,154,.10), transparent 60%),
        url("assets/matrix.jpg") center/cover no-repeat;
      filter:saturate(1.1) contrast(1.08);
      transform:scale(1.02);
      z-index:2;
    }
    .vignette{
      position:fixed; 
      inset:-40px; 
      background:radial-gradient(circle at 50% 55%, transparent 35%, rgba(0,0,0,.8) 78%); 
      pointer-events:none;
      z-index:3;
    }
    .scanlines{
      position:fixed; 
      inset:0; 
      background:repeating-linear-gradient(to bottom, rgba(255,255,255,.02), rgba(255,255,255,.02) 1px, rgba(0,0,0,0) 3px, rgba(0,0,0,0) 6px); 
      mix-blend-mode:overlay; 
      opacity:.45; 
      pointer-events:none;
      z-index:4;
      animation:scan 8s linear infinite;
    }
    @keyframes scan{
      0%{transform:translateY(0)}
      100%{transform:translateY(10px)}
    }

    /* Floating particles */
    .particles{
      position:fixed;
      inset:0;
      pointer-events:none;
      z-index:3;
    }
    .particle{
      position:absolute;
      width:3px;
      height:3px;
      background:var(--green);
      border-radius:50%;
      opacity:0;
      animation:float 15s infinite;
      box-shadow:0 0 10px var(--green);
    }
    @keyframes float{
      0%{opacity:0;transform:translateY(100vh) translateX(0)}
      10%{opacity:0.6}
      90%{opacity:0.3}
      100%{opacity:0;transform:translateY(-20vh) translateX(100px)}
    }

    .wrap{
      position:relative;
      height:100%;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      z-index:10;
    }
    .panel{
      width:min(980px,96vw); 
      height:min(640px,92vh);
      border:1px solid rgba(0,255,154,.35);
      border-radius:18px;
      background:linear-gradient(180deg, rgba(0,0,0,.65), rgba(0,0,0,.45));
      box-shadow:
        0 0 0 1px rgba(0,255,154,.15) inset, 
        0 0 40px rgba(0,255,154,.2),
        0 25px 80px rgba(0,0,0,.7);
      position:relative; 
      overflow:hidden;
      animation:panelGlow 3s ease-in-out infinite;
    }
    @keyframes panelGlow{
      0%, 100%{box-shadow:0 0 0 1px rgba(0,255,154,.15) inset, 0 0 40px rgba(0,255,154,.2), 0 25px 80px rgba(0,0,0,.7);}
      50%{box-shadow:0 0 0 1px rgba(0,255,154,.25) inset, 0 0 60px rgba(0,255,154,.3), 0 25px 80px rgba(0,0,0,.7);}
    }

    .hud{
      position:absolute; 
      left:16px; 
      right:16px; 
      top:14px;
      display:flex; 
      align-items:center; 
      justify-content:space-between; 
      gap:12px;
      pointer-events:none;
      z-index:20;
    }
    .brand{display:flex;flex-direction:column;gap:2px;}
    .brand b{
      letter-spacing:.30em;
      color:var(--green);
      text-shadow:0 0 15px rgba(0,255,154,.5), 0 0 30px rgba(0,255,154,.3);
      font-size:14px;
      animation:glitch 5s infinite;
    }
    @keyframes glitch{
      0%, 90%, 100%{transform:translate(0)}
      91%{transform:translate(-2px, 1px)}
      92%{transform:translate(2px, -1px)}
      93%{transform:translate(0)}
    }

    .status{
      font-size:12px;
      color:#bfffe7;
      opacity:.9;
      text-align:right;
      display:flex;
      align-items:center;
      gap:8px;
    }
    .status .dot{
      display:inline-block;
      width:8px;
      height:8px;
      border-radius:50%;
      background:var(--green);
      box-shadow:0 0 12px rgba(0,255,154,.8);
      animation:pulse 2s ease-in-out infinite;
    }
    @keyframes pulse{
      0%, 100%{opacity:1;transform:scale(1)}
      50%{opacity:0.6;transform:scale(0.9)}
    }

    .screen{
      position:absolute; 
      inset:0; 
      display:flex; 
      align-items:center; 
      justify-content:center; 
      padding:26px;
      opacity:0;
      transition:opacity 0.4s ease;
    }
    .screen.active{opacity:1;}
    .hidden{display:none;}

    .card{
      width:min(720px,92%);
      background:rgba(0,0,0,.55);
      border:1px solid rgba(0,255,154,.25);
      border-radius:18px;
      padding:26px 24px;
      box-shadow:
        0 0 0 1px rgba(0,255,154,.12) inset,
        0 10px 40px rgba(0,0,0,.5);
      backdrop-filter:blur(10px);
      text-align:center;
      transform:scale(0.95);
      transition:transform 0.4s ease;
    }
    .screen.active .card{transform:scale(1);}

    .title{
      margin:0 0 10px;
      font-size:26px;
      letter-spacing:.08em;
      text-shadow:0 0 20px rgba(0,255,154,.3);
      background:linear-gradient(135deg, #fff, var(--green));
      -webkit-background-clip:text;
      -webkit-text-fill-color:transparent;
      background-clip:text;
    }
    .subtitle{margin:0 0 14px;font-size:13px;line-height:1.45;opacity:.9;}
    .controls{margin-top:18px;display:flex;gap:14px;justify-content:center;flex-wrap:wrap;}

    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.18);
      border-radius:16px;
      background:rgba(0,0,0,.6);
      color:#fff;
      padding:14px 20px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      transition:all .2s ease;
      -webkit-tap-highlight-color:transparent;
      display:flex;
      align-items:center;
      justify-content:center;
      gap:10px;
      position:relative;
      overflow:hidden;
    }
    .btn:before{
      content:'';
      position:absolute;
      inset:0;
      background:linear-gradient(135deg, transparent, rgba(255,255,255,.1), transparent);
      transform:translateX(-100%);
      transition:transform 0.6s;
    }
    .btn:hover:before{transform:translateX(100%);}
    .btn:hover{
      transform:translateY(-2px);
      box-shadow:0 5px 20px rgba(0,255,154,.3);
    }
    .btn:active{transform:translateY(0) scale(.98);}
    .btn.blue{border-color:rgba(31,111,255,.4); box-shadow:0 0 15px rgba(31,111,255,.2);}
    .btn.blue:hover{box-shadow:0 5px 25px rgba(31,111,255,.4);}
    .btn.red{border-color:rgba(255,45,45,.4); box-shadow:0 0 15px rgba(255,45,45,.2);}
    .btn.red:hover{box-shadow:0 5px 25px rgba(255,45,45,.4);}
    .btn.green{border-color:rgba(0,255,154,.35); box-shadow:0 0 15px rgba(0,255,154,.2);}
    .btn.green:hover{box-shadow:0 5px 25px rgba(0,255,154,.4);}

    .pill{
      width:24px;
      height:14px;
      border-radius:999px;
      position:relative;
      display:inline-block;
      border:1px solid rgba(255,255,255,.2);
      overflow:hidden;
    }
    .pill:before,.pill:after{content:"";position:absolute;inset:0;width:50%;opacity:.95;}
    .pill:after{left:50%;}
    .pill.blue:before{background:rgba(31,111,255,.95);} 
    .pill.blue:after{background:rgba(0,0,0,.3);}
    .pill.red:before{background:rgba(255,45,45,.95);}   
    .pill.red:after{background:rgba(0,0,0,.3);}

    .menuGrid{
      display:grid;
      grid-template-columns:repeat(2,minmax(0,1fr));
      gap:14px;
      margin-top:16px;
    }
    .menuBtn{
      z-index:1;
      border:1px solid rgba(0,255,154,.22);
      background:rgba(0,0,0,.45);
      color:#dfffee;
      border-radius:16px;
      padding:18px 14px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      transition:all 0.3s ease;
      position:relative;
      overflow:hidden;
    }
    .menuBtn:before{
      content:'';
      position:absolute;
      inset:0;
      background:linear-gradient(135deg, transparent, rgba(0,255,154,.1), transparent);
      transform:translateX(-100%);
      transition:transform 0.6s;
    }
    .menuBtn:hover:before{transform:translateX(100%);}
    .menuBtn:hover{
      transform:translateY(-3px);
      border-color:rgba(0,255,154,.4);
      box-shadow:0 8px 25px rgba(0,255,154,.25);
    }
    .menuBtn:active{transform:translateY(0) scale(.98);}
    .menuBtn .btnCaption{
      font-size:10px;
      font-weight:400;
      letter-spacing:.04em;
      text-transform:none;
      opacity:.7;
      line-height:1.3;
      max-width:90%;
    }
    .menuBtn .newBadge{
      position:absolute;
      top:8px;
      right:8px;
      background:var(--red);
      color:#fff;
      font-size:9px;
      padding:3px 6px;
      border-radius:8px;
      font-weight:900;
      box-shadow:0 0 10px rgba(255,45,45,.6);
      animation:badgePulse 2s infinite;
    }
    @keyframes badgePulse{
      0%, 100%{transform:scale(1)}
      50%{transform:scale(1.1)}
    }

    .playerbar{
      position:absolute; 
      left:16px; 
      right:16px; 
      bottom:16px;
      border-radius:16px; 
      border:1px solid rgba(0,255,154,.25);
      background:rgba(0,0,0,.5);
      padding:14px 16px;
      backdrop-filter:blur(12px);
      box-shadow:0 0 30px rgba(0,0,0,.6), 0 0 0 1px rgba(0,255,154,.15) inset;
      display:none;
      z-index:30;
    }
    .playerbar.on{display:block;}
    
    .track{
      font-size:13px;
      font-weight:700;
      opacity:.95;
      margin-bottom:10px;
      text-align:center;
      letter-spacing:.06em;
      color:var(--green);
      text-shadow:0 0 10px rgba(0,255,154,.4);
    }
    .progress-info{
      display:flex;
      justify-content:center;
      font-size:11px;
      opacity:.75;
      margin-bottom:8px;
    }
    
    audio,video{width:100%;margin:10px 0;}
    video{max-height:240px;border-radius:8px;}
    
    .player-controls{
      display:flex;
      gap:8px;
      justify-content:center;
      margin-top:12px;
      flex-wrap:wrap;
    }
    .player-controls button{
      border:1px solid rgba(255,255,255,.2);
      background:rgba(0,0,0,.4);
      color:#dfffee;
      border-radius:12px;
      padding:8px 14px;
      cursor:pointer;
      font-weight:700;
      font-size:11px;
      transition:all 0.2s;
      text-transform:uppercase;
      letter-spacing:.05em;
    }
    .player-controls button:hover{
      background:rgba(0,255,154,.2);
      border-color:rgba(0,255,154,.4);
      transform:translateY(-1px);
    }
    .player-controls button.active{
      background:rgba(0,255,154,.3);
      border-color:var(--green);
    }

    .row{display:flex;justify-content:center;margin-top:14px;}
    .ghost{
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.35);
      color:#dfffee;
      border-radius:14px;
      padding:10px 16px;
      cursor:pointer;
      font-weight:700;
      transition:all 0.2s;
    }
    .ghost:hover{
      background:rgba(255,255,255,.1);
      transform:translateY(-2px);
    }

    .stopBtn{
      border:1px solid rgba(255,45,45,.4);
      background:rgba(0,0,0,.6);
      color:#ff2d2d;
      border-radius:12px;
      padding:10px 16px;
      cursor:pointer;
      font-weight:900;
      letter-spacing:.06em;
      text-transform:uppercase;
      margin-top:10px;
      width:100%;
      transition:all 0.2s;
    }
    .stopBtn:hover{
      background:rgba(255,45,45,.2);
      border-color:var(--red);
      box-shadow:0 0 20px rgba(255,45,45,.3);
    }
    .stopBtn:active{transform:scale(.98);}

    /* Playing indicator */
    .playing-indicator{
      display:none;
      align-items:center;
      gap:4px;
      margin-left:8px;
    }
    .playing-indicator.active{display:inline-flex;}
    .bar{
      width:3px;
      height:12px;
      background:var(--green);
      animation:soundbar 0.8s ease-in-out infinite;
    }
    .bar:nth-child(1){animation-delay:0s;}
    .bar:nth-child(2){animation-delay:0.2s;}
    .bar:nth-child(3){animation-delay:0.4s;}
    @keyframes soundbar{
      0%, 100%{height:6px}
      50%{height:14px}
    }

    @media (max-width:640px){
      .menuGrid{grid-template-columns:1fr;}
      video{max-height:200px;}
      .title{font-size:22px;}
    }

    /* =======================
       OCHO ORACLE STYLES
       ======================= */
    
    /* Pulsante OCHO con effetto stelline magiche */
    .ochoBtn{
      position:relative;
      overflow:hidden;
    }
    
    .ochoBtn::before{
      content:'';
      position:absolute;
      inset:0;
      border-radius:inherit;
      pointer-events:none;
      background:radial-gradient(circle at 50% 50%, rgba(168,85,247,.28), rgba(0,255,154,.18), transparent 70%);
      opacity:0.0;
      animation:ochoGlow 3s ease-in-out infinite;
    }

    .ochoBtn::after{
      content:'';
      position:absolute;
      inset:0;
      border-radius:inherit;
      pointer-events:none;
      box-shadow:0 0 18px rgba(0,255,154,.18), 0 0 28px rgba(168,85,247,.10);
      opacity:0.35;
      animation:ochoGlow 3s ease-in-out infinite;
    }

    
    .ochoBtn > *{ position:relative; z-index:2; }
@keyframes ochoGlow{
      0%, 100%{opacity:0.4; filter:blur(8px);}
      50%{opacity:0.8; filter:blur(12px);}
    }
    
    /* Stelline magiche */
    .sparkle{
      position:absolute;
      width:4px;
      height:4px;
      background:var(--green);
      border-radius:50%;
      box-shadow:0 0 10px var(--green), 0 0 20px var(--green);
      animation:sparkleFloat 2s ease-in-out infinite;
      pointer-events:none;
    }
    
    @keyframes sparkleFloat{
      0%{opacity:0; transform:translateY(0) scale(0);}
      50%{opacity:1; transform:translateY(-20px) scale(1);}
      100%{opacity:0; transform:translateY(-40px) scale(0);}
    }
    
    /* Chat Oracle */
    .oracleChat{
      max-height:340px;
      overflow-y:auto;
      background:rgba(0,0,0,.4);
      border:1px solid rgba(0,255,154,.2);
      border-radius:12px;
      padding:16px;
      margin:16px 0;
      font-size:14px;
      line-height:1.6;
    }
    
    .oracleChat::-webkit-scrollbar{width:6px;}
    .oracleChat::-webkit-scrollbar-track{background:rgba(0,0,0,.3);}
    .oracleChat::-webkit-scrollbar-thumb{background:rgba(0,255,154,.4);border-radius:3px;}
    
    .message{
      margin-bottom:12px;
      padding:10px 14px;
      border-radius:10px;
      animation:messageSlide 0.3s ease;
    }
    
    @keyframes messageSlide{
      from{opacity:0; transform:translateY(10px);}
      to{opacity:1; transform:translateY(0);}
    }
    
    .message.user{
      background:rgba(31,111,255,.25);
      border:1px solid rgba(31,111,255,.4);
      text-align:right;
    }
    
    .message.oracle{
      background:rgba(0,255,154,.15);
      border:1px solid rgba(0,255,154,.3);
      color:var(--green);
    }

    .message.oracle{
      border:1px solid rgba(0,255,154,.18);
      background:rgba(0,0,0,.45);
      box-shadow:0 0 22px rgba(0,255,154,.06);
      text-shadow:0 0 10px rgba(0,255,154,.10);
      animation:magicEmergence .55s ease-out both;
    }
    .message.oracle.typing{
      animation:none;
      text-shadow:0 0 14px rgba(0,255,154,.16), 0 0 26px rgba(168,85,247,.08);
    }
    @keyframes magicEmergence{
      0%{opacity:0; filter:blur(10px); transform:translateY(6px) scale(.98);}
      100%{opacity:1; filter:blur(0); transform:translateY(0) scale(1);}
    }

    
    .message.system{
      background:rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.15);
      font-size:12px;
      opacity:0.8;
      text-align:center;
    }
    
    
    /* Fallback tastiera (quando il microfono non √® disponibile) */
    .kbWrap{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:center;
      margin-top:14px;
      width:100%;
    }
    .kbWrap.hidden{display:none;}
    .kbInput{
      flex:1;
      max-width:420px;
      width:70%;
      padding:12px 14px;
      border-radius:12px;
      border:1px solid rgba(0,255,154,.22);
      background:rgba(0,0,0,.55);
      color:rgba(255,255,255,.92);
      outline:none;
      font-size:14px;
    }
    .kbInput:focus{
      border-color:rgba(0,255,154,.45);
      box-shadow:0 0 0 3px rgba(0,255,154,.08);
    }
    .kbSend{
      padding:12px 14px;
      border-radius:12px;
      border:1px solid rgba(0,255,154,.25);
      background:rgba(0,0,0,.65);
      color:var(--green);
      cursor:pointer;
      font-weight:700;
      letter-spacing:.3px;
    }
    .kbSend:hover{
      border-color:rgba(0,255,154,.45);
      transform:translateY(-1px);
    }

/* Pulsante microfono Oracle */
    .micBtn{
      width:64px;
      height:64px;
      border-radius:50%;
      background:rgba(0,0,0,.7);
      border:2px solid rgba(0,255,154,.4);
      color:var(--green);
      font-size:28px;
      cursor:pointer;
      transition:all 0.3s ease;
      display:flex;
      align-items:center;
      justify-content:center;
      margin:0 auto;
      box-shadow:0 0 20px rgba(0,255,154,.2);
    }
    
    .micBtn:hover{
      transform:scale(1.1);
      box-shadow:0 0 30px rgba(0,255,154,.4);
      border-color:var(--green);
    }
    
    .micBtn.listening{
      background:rgba(0,255,154,.2);
      animation:micPulse 1s ease-in-out infinite;
      border-color:var(--green);
    }
    
    @keyframes micPulse{
      0%, 100%{box-shadow:0 0 20px rgba(0,255,154,.4);}
      50%{box-shadow:0 0 40px rgba(0,255,154,.8);}
    }
    
    .oracleControls{
      display:flex;
      gap:8px;
      justify-content:center;
      flex-wrap:wrap;
      margin-top:16px;
    }
    
    .miniBtn{
      padding:8px 16px;
      font-size:12px;
      border-radius:10px;
      background:rgba(0,0,0,.6);
      border:1px solid rgba(255,255,255,.15);
      color:#fff;
      cursor:pointer;
      transition:all 0.2s;
    }
    
    .miniBtn:hover{
      background:rgba(0,255,154,.15);
      border-color:var(--green);
      transform:translateY(-2px);
    }
  </style>
</head>

<body>
  <!-- Matrix Rain Canvas -->
  <canvas id="matrixCanvas"></canvas>
  
  <!-- Floating particles -->
  <div class="particles" id="particles"></div>

  <div class="bg" id="bg"></div>
  <div class="vignette"></div>
  <div class="scanlines"></div>

  <div class="wrap">
    <div class="panel">
      <div class="hud">
        <div class="brand"><b>O C H O</b></div>
        <div class="status">
          <span class="dot"></span>
          <span id="statusText">In attesa‚Ä¶</span>
          <div class="playing-indicator" id="playingIndicator">
            <div class="bar"></div>
            <div class="bar"></div>
            <div class="bar"></div>
          </div>
        </div>
      </div>

      <!-- SCREEN: TOCCA PER ENTRARE -->
      <div class="screen active" id="screenEnter">
        <div class="card">
          <h1 class="title">TOCCA PER ENTRARE</h1>
<div class="controls">
            <button class="btn green" id="enterBtn">ACCEDI AL SISTEMA</button>
          </div>
        </div>
      </div>

      <!-- SCREEN: PILLs -->
      <div class="screen hidden" id="screenPills">
        <div class="card">
          <h1 class="title">SCEGLI LA PILLOLA</h1>
          <p class="subtitle">Pillola blu: ritorni alla realt√†<br>Pillola rossa: scopri quanto √® profonda la tana</p>
          <div class="controls">
            <button class="btn blue" id="blueBtn"><span class="pill blue"></span>Pillola Blu</button>
            <button class="btn red" id="redBtn"><span class="pill red"></span>Pillola Rossa</button>
          </div>
        </div>
      </div>

      <!-- SCREEN: RED MENU -->
      <div class="screen hidden" id="screenMenu">
        <div class="card">
          <h1 class="title">ARCHIVIO DIGITALE</h1>
<div class="menuGrid">
            <button class="menuBtn" data-cat="frasi">
              <span>FRASI</span>
              <span class="btnCaption">assiomi da cui partire, non conclusioni da dimostrare</span>
              <span class="newBadge" data-badge="frasi" style="display:none">NEW</span>
            </button>
            <button class="menuBtn" data-cat="song">
              <span>SONG</span>
              <span class="btnCaption">frequenze sonore del campo</span>
              <span class="newBadge" data-badge="song" style="display:none">NEW</span>
            </button>
            <button class="menuBtn" data-cat="podcast">
              <span>PODCAST</span>
              <span class="btnCaption">episodi audio on-demand</span>
              <span class="newBadge" data-badge="podcast" style="display:none">NEW</span>
            </button>
            <button class="menuBtn" data-cat="video">
              <span>VIDEO</span>
              <span class="btnCaption">proiezioni visive della matrice</span>
              <span class="newBadge" data-badge="video" style="display:none">NEW</span>
            </button>
            <button class="menuBtn ochoBtn" id="ochoBtn">
              <span>üîÆ OCHO</span>
              <span class="btnCaption">consulta l'oracolo del sistema</span>
            </button>
          </div>

          <div class="row">
            <button class="ghost" id="backToPills">‚üµ Torna alle pillole</button>
          </div>
        </div>
      </div>

      <!-- SCREEN: ORACLE OCHO -->
      <div class="screen hidden" id="screenOracle">
        <div class="card">
          <h1 class="title">OCHO RISPONDE ALLE TUE DOMANDE</h1>
<!-- Chat messages -->
          <div class="oracleChat" id="oracleChat">
            
          </div>

          <!-- Microfono -->
          <button class="micBtn" id="micBtn" title="Clicca per parlare">
            üé§
          </button>

          <!-- Controlli -->
          <div class="oracleControls">
            <button class="miniBtn" id="clearChatBtn">üóëÔ∏è Pulisci Chat</button>
            <button class="miniBtn" id="backFromOracle">‚Üê Menu</button>
          </div>
        </div>
      </div>

      <!-- PLAYER -->
      <div class="playerbar" id="playerbar">
        <div class="track" id="track">‚Äî</div>
        <div class="progress-info"><span id="progressText">File 0/0</span>&nbsp;‚Ä¢&nbsp;<span id="filename">‚Äî</span></div>
        <div class="progress-info">
          <span id="timeText">0:00 / 0:00</span>
        </div>
        <audio id="audio" controls></audio>
        <video id="video" controls class="hidden"></video>
        
        <div class="player-controls">
          <button id="prevBtn">‚óÑ PREC</button>
          <button id="nextBtn">SUCC ‚ñ∫</button>
          <button id="shuffleBtn">‚ßâ CASUALE</button>
        </div>
        
        <button class="stopBtn" id="stopBtn">‚ñ† STOP - TORNA AL MENU</button>
      </div>

      <!-- AUDIO INTRO -->
      <audio id="introAudio" preload="auto" src="mp3/inizio.mp3"></audio>
    </div>
  </div>

<script>
/* =======================
   CONFIG GITHUB
   ======================= */
const GITHUB_USER = "fabriziodadamo72-source";
const GITHUB_REPO = "jukebox-random";
const GITHUB_BRANCH = "main";
const ANSA_URL = "https://www.ansa.it/";

const FOLDERS = {
  frasi: { path: "mp3", exts: [".mp3"], exclude: ["inizio.mp3"] },
  song: { path: "song", exts: [".mp3"] },
  podcast: { path: "broadcast", exts: [".mp3"] },
  video: { path: "mp4", exts: [".mp4", ".avi", ".mov", ".webm"] }
};

/* =======================
   ORACLE API KEYS
   ======================= */
// === OCHO ORACLE (RAG) ===
// L'API key serve SOLO per chiamare un modello (opzionale). La ricerca nel tuo archivio avviene qui in JS.
const GROQ_API_KEY = "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"; // <-- incolla qui la tua Groq API key (opzionale). Se vuota, OCHO risponde solo con l'archivio.
const GROQ_MODEL = "llama-3.1-70b-versatile"; // puoi cambiare modello se vuoi

// Text-to-Speech (opzionale)
const ELEVENLABS_API_KEY = ""; // <-- incolla qui la tua ElevenLabs key (opzionale)
const ELEVENLABS_VOICE_ID = "kKnIQQYgU6nl3rbQsBWE"; // Jack - smooth, deep, mysterious
/* =======================
   STATE
   ======================= */
const playlists = new Map();
const decks = new Map();
const deckPos = new Map();
let currentCat = "frasi";
let shuffleMode = true;
let playHistory = [];

// AUTOMATIC NEW DETECTION
let fileSnapshots = {}; // Snapshot dei file alla prima visita
let seenFiles = {}; // File che l'utente ha effettivamente ascoltato

// MIGRAZIONE: rinomina categoria "broadcast" -> "podcast" nei salvataggi vecchi
try {
  const snapRaw = localStorage.getItem('ocho_snapshots');
  if (snapRaw) {
    const s = JSON.parse(snapRaw);
    if (s.broadcast && !s.podcast) { s.podcast = s.broadcast; delete s.broadcast; localStorage.setItem('ocho_snapshots', JSON.stringify(s)); }
  }
  const seenRaw = localStorage.getItem('ocho_seen');
  if (seenRaw) {
    const v = JSON.parse(seenRaw);
    if (v.broadcast && !v.podcast) { v.podcast = v.broadcast; delete v.broadcast; localStorage.setItem('ocho_seen', JSON.stringify(v)); }
  }
} catch(e) {}

// Load from localStorage
try {
  if (localStorage.getItem('ocho_snapshots')) {
    fileSnapshots = JSON.parse(localStorage.getItem('ocho_snapshots'));
  }
  if (localStorage.getItem('ocho_seen')) {
    seenFiles = JSON.parse(localStorage.getItem('ocho_seen'));
  }
} catch(e) {
  console.log("localStorage error:", e);
}

/* =======================
   ORACLE STATE
   ======================= */
let recognition = null;
let isListening = false;
let libraryLoaded = false;
let libraryTexts = [];

/* =======================
   ELEMENTS
   ======================= */
const bg = document.getElementById("bg");
const statusText = document.getElementById("statusText");
const playingIndicator = document.getElementById("playingIndicator");

const screenEnter = document.getElementById("screenEnter");
const screenPills = document.getElementById("screenPills");
const screenMenu = document.getElementById("screenMenu");
const screenOracle = document.getElementById("screenOracle");

const introAudio = document.getElementById("introAudio");

const playerbar = document.getElementById("playerbar");
const trackEl = document.getElementById("track");
const filenameEl = document.getElementById("filename");
const progressText = document.getElementById("progressText");
const timeText = document.getElementById("timeText");
const audio = document.getElementById("audio");
const video = document.getElementById("video");
const shuffleBtn = document.getElementById("shuffleBtn");

/* =======================
   MATRIX RAIN EFFECT
   ======================= */
const canvas = document.getElementById("matrixCanvas");
const ctx = canvas.getContext("2d");

canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@#$%^&*()";
const fontSize = 14;
const columns = canvas.width / fontSize;
const drops = Array(Math.floor(columns)).fill(1);

function drawMatrix() {
  ctx.fillStyle = "rgba(0, 0, 0, 0.05)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  
  ctx.fillStyle = "#00ff9a";
  ctx.font = fontSize + "px monospace";
  
  for (let i = 0; i < drops.length; i++) {
    const text = chars[Math.floor(Math.random() * chars.length)];
    ctx.fillText(text, i * fontSize, drops[i] * fontSize);
    
    if (drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
      drops[i] = 0;
    }
    drops[i]++;
  }
}

setInterval(drawMatrix, 50);

window.addEventListener("resize", () => {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
});

/* =======================
   FLOATING PARTICLES
   ======================= */
function createParticles() {
  const container = document.getElementById("particles");
  for (let i = 0; i < 20; i++) {
    const particle = document.createElement("div");
    particle.className = "particle";
    particle.style.left = Math.random() * 100 + "%";
    particle.style.animationDelay = Math.random() * 15 + "s";
    particle.style.animationDuration = (10 + Math.random() * 10) + "s";
    container.appendChild(particle);
  }
}
createParticles();

/* =======================
   HELPERS
   ======================= */
function setStatus(msg) { 
  statusText.textContent = msg; 
}

function show(which) {
  // which can be: "enter", "pills", "menu", "oracle"
  document.querySelectorAll(".screen").forEach(s => {
    s.classList.remove("active");
    s.classList.add("hidden");
  });

  const id = `screen${which.charAt(0).toUpperCase() + which.slice(1)}`;
  const target = document.getElementById(id);
  if (!target) {
    console.warn("Screen not found:", id);
    return;
  }
  target.classList.remove("hidden");
  requestAnimationFrame(() => target.classList.add("active"));
}

function showPlayer(on) { 
  playerbar.classList.toggle("on", !!on); 
  playingIndicator.classList.toggle("active", !!on);
}

function shuffle(arr) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function formatTime(seconds) {
  const mins = Math.floor(seconds / 60);
  const secs = Math.floor(seconds % 60);
  return `${mins}:${secs.toString().padStart(2, '0')}`;
}

/* =======================
   AUTOMATIC NEW DETECTION (SHA-based + Timestamp)
   ======================= */
const NEW_FILE_DAYS = 30; // File √® NEW per max 30 giorni da quando l'hai scoperto

function saveSnapshotWithHashes(cat, filesWithHashes) {
  // Salva SHA dei file + timestamp di quando li hai visti la prima volta
  if (!fileSnapshots[cat]) {
    fileSnapshots[cat] = {};
  }
  
  const now = new Date().toISOString();
  
  filesWithHashes.forEach(fileObj => {
    // Se √® un file gi√† conosciuto, mantieni il timestamp originale
    if (!fileSnapshots[cat][fileObj.name]) {
      fileSnapshots[cat][fileObj.name] = {
        sha: fileObj.sha,
        firstSeen: now  // Quando l'hai visto la prima volta
      };
    } else {
      // File esistente: aggiorna SHA se cambiato
      fileSnapshots[cat][fileObj.name].sha = fileObj.sha;
    }
  });
  
  localStorage.setItem('ocho_snapshots', JSON.stringify(fileSnapshots));
  console.log(`üì∏ Snapshot salvato per ${cat}:`, filesWithHashes.length, 'file');
}

function isFileRecentlyDiscovered(firstSeenDate) {
  // Controlla se il file √® stato scoperto negli ultimi X giorni
  if (!firstSeenDate) return true; // Se non ha data, consideralo nuovo
  
  const discoveredDate = new Date(firstSeenDate);
  const now = new Date();
  const daysDiff = (now - discoveredDate) / (1000 * 60 * 60 * 24);
  
  return daysDiff <= NEW_FILE_DAYS;
}

function isNewAndUnseen(cat, filename) {
  // Un file √® "NEW e non visto" se:
  // 1. √à stato scoperto negli ultimi 30 giorni
  // 2. L'utente NON l'ha ancora ascoltato
  
  if (!fileSnapshots[cat] || !fileSnapshots[cat][filename]) {
    // File mai visto prima = NEW
    return true;
  }
  
  const fileInfo = fileSnapshots[cat][filename];
  const isRecentlyDiscovered = isFileRecentlyDiscovered(fileInfo.firstSeen);
  const hasBeenSeen = seenFiles[cat] && seenFiles[cat].includes(filename);
  
  return isRecentlyDiscovered && !hasBeenSeen;
}

function markAsSeen(cat, filename) {
  if (!seenFiles[cat]) seenFiles[cat] = [];
  if (!seenFiles[cat].includes(filename)) {
    seenFiles[cat].push(filename);
    localStorage.setItem('ocho_seen', JSON.stringify(seenFiles));
    console.log(`‚úÖ ${filename} marcato come visto`);
    
    // Aggiorna i badge dopo aver visto un file
    updateNewBadges();
  }
}

function updateNewBadges() {
  // Aggiorna i badge con il conteggio dei file nuovi non ascoltati
  for (const cat in fileSnapshots) {
    const badge = document.querySelector(`[data-badge="${cat}"]`);
    if (!badge) continue;
    
    const filesInCat = fileSnapshots[cat];
    
    // Conta file recentemente scoperti NON ancora visti
    let newUnseenCount = 0;
    for (const filename in filesInCat) {
      const fileInfo = filesInCat[filename];
      const isRecent = isFileRecentlyDiscovered(fileInfo.firstSeen);
      const hasBeenSeen = seenFiles[cat] && seenFiles[cat].includes(filename);
      
      if (isRecent && !hasBeenSeen) {
        newUnseenCount++;
      }
    }
    
    if (newUnseenCount > 0) {
      badge.style.display = "block";
      badge.textContent = `${newUnseenCount} NEW`;
      console.log(`üÜï ${cat}: ${newUnseenCount} file nuovi non visti`);
    } else {
      badge.style.display = "none";
    }
  }
}

async function preloadAllCategories() {
  // Pre-carica tutte le categorie in background per calcolare i badge
  console.log("üîÑ Pre-caricamento categorie per badge NEW...");
  
  for (const cat in FOLDERS) {
    try {
      await loadCat(cat);
    } catch(e) {
      console.log(`Errore pre-caricamento ${cat}:`, e);
    }
  }
  
  console.log("‚úÖ Pre-caricamento completato!");
  updateNewBadges();
}

async function loadCategoriesInBackground() {
  // Carica progressivamente solo le categorie NON ancora caricate
  console.log("üîÑ Caricamento progressivo in background...");
  
  for (const cat in FOLDERS) {
    // Salta se gi√† caricata
    if (playlists.has(cat)) {
      console.log(`‚è≠Ô∏è ${cat} gi√† caricata`);
      continue;
    }
    
    try {
      console.log(`‚è≥ Caricamento ${cat}...`);
      await loadCat(cat);
      
      // Pausa tra categorie per evitare rate limiting
      await new Promise(resolve => setTimeout(resolve, 1000));
    } catch(e) {
      console.log(`‚ùå Errore ${cat}:`, e);
    }
  }
  
  console.log("‚úÖ Caricamento background completato!");
}

/* =======================
   GITHUB API
   ======================= */
async function fetchGitHubFolder(folderPath) {
  const url = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents/${folderPath}?ref=${GITHUB_BRANCH}`;
  try {
    const res = await fetch(url);
    if (!res.ok) throw new Error(`GitHub API error: ${res.status}`);
    const data = await res.json();
    
    // Ottieni file con SHA (hash) invece di date commit
    // SHA cambia quando il file cambia - pi√π veloce!
    const filesWithHashes = data
      .filter(item => item.type === "file")
      .map(item => ({
        name: item.name,
        sha: item.sha,  // Hash unico del file
        size: item.size
      }));
    
    return filesWithHashes;
  } catch (e) {
    console.error("Errore fetch GitHub:", e);
    return [];
  }
}

async function loadCat(cat) {
  if (playlists.has(cat)) {
    // Se gi√† caricata, aggiorna solo i badge
    updateNewBadges();
    return true;
  }
  
  setStatus(`Caricamento ${cat}...`);
  const config = FOLDERS[cat];
  if (!config) {
    console.error("Categoria sconosciuta:", cat);
    return false;
  }

  const allFilesWithHashes = await fetchGitHubFolder(config.path);
  
  // Filtra per estensione ed esclusioni
  let filesWithHashes = allFilesWithHashes.filter(fileObj => {
    const lower = fileObj.name.toLowerCase();
    const hasExt = config.exts.some(ext => lower.endsWith(ext));
    const isExcluded = (config.exclude || []).some(ex => fileObj.name === ex);
    return hasExt && !isExcluded;
  });

  if (!filesWithHashes.length) {
    setStatus(`Nessun file in ${cat}`);
    trackEl.textContent = `ERRORE: Nessun file trovato in ${config.path}/`;
    showPlayer(true);
    return false;
  }

  // Crea array di percorsi completi
  const files = filesWithHashes.map(f => `${config.path}/${f.name}`);
  playlists.set(cat, files);
  
  // SNAPSHOT CON HASH: salva nome file + SHA + timestamp
  saveSnapshotWithHashes(cat, filesWithHashes);
  
  resetDeck(cat);
  
  // Aggiorna i badge dopo il caricamento
  updateNewBadges();
  
  console.log(`‚úÖ ${cat}: ${files.length} file caricati`);
  return true;
}

function resetDeck(cat) {
  const files = playlists.get(cat) || [];
  const n = files.length;
  const indices = [...Array(n).keys()];
  
  // Separa indici di file NEW non visti da altri
  const newIndices = [];
  const otherIndices = [];
  
  indices.forEach(idx => {
    const filename = files[idx].split('/').pop();
    if (isNewAndUnseen(cat, filename)) {
      newIndices.push(idx);
    } else {
      otherIndices.push(idx);
    }
  });
  
  // Shuffle separatamente
  const shuffledNew = shuffleMode ? shuffle([...newIndices]) : newIndices;
  const shuffledOthers = shuffleMode ? shuffle([...otherIndices]) : otherIndices;
  
  // Metti i NEW all'inizio
  const finalDeck = [...shuffledNew, ...shuffledOthers];
  
  decks.set(cat, finalDeck);
  deckPos.set(cat, 0);
}

function draw(cat) {
  const list = playlists.get(cat) || [];
  if (!list.length) return -1;
  if (!decks.has(cat) || !deckPos.has(cat)) resetDeck(cat);

  let p = deckPos.get(cat);
  const d = decks.get(cat);
  if (p >= d.length) { resetDeck(cat); p = 0; }
  const idx = d[p];
  deckPos.set(cat, p + 1);
  return idx;
}

function drawPrev(cat) {
  const list = playlists.get(cat) || [];
  if (!list.length) return -1;
  
  let p = deckPos.get(cat);
  p = p - 2; // Go back 2 (one for current, one for previous)
  if (p < 0) p = decks.get(cat).length - 1;
  deckPos.set(cat, p);
  
  return draw(cat);
}

function updateProgress() {
  const pos = deckPos.get(currentCat) || 0;
  const total = (playlists.get(currentCat) || []).length;
  if (progressText) progressText.textContent = `File ${Math.min(pos, total)}/${total}`;
}

function updateTime() {
  const media = currentCat === "video" ? video : audio;
  if (media.duration) {
    timeText.textContent = `${formatTime(media.currentTime)} / ${formatTime(media.duration)}`;
  }
}

function playPath(cat, src) {
  currentCat = cat;
  showPlayer(true);
  trackEl.textContent = `[${cat.toUpperCase()}]`;
  
  const filename = src.split("/").pop();
  if (filenameEl) filenameEl.textContent = filename;
  
  // Marca il file come visto
  markAsSeen(cat, filename);
  
  setStatus("In riproduzione‚Ä¶");

  if (cat === "video") {
    audio.pause();
    audio.classList.add("hidden");
    video.classList.remove("hidden");
    video.src = src;
    video.play().then(() => {
      if (video.requestFullscreen) {
        video.requestFullscreen().catch(() => {});
      } else if (video.webkitRequestFullscreen) {
        video.webkitRequestFullscreen();
      } else if (video.mozRequestFullScreen) {
        video.mozRequestFullScreen();
      }
    }).catch(() => {});
  } else {
    video.pause();
    video.classList.add("hidden");
    audio.classList.remove("hidden");
    audio.src = src;
    audio.play().catch(() => {});
  }
  
  playHistory.push({cat, src, time: new Date()});
  if (playHistory.length > 50) playHistory.shift();
}

async function playNext(cat) {
  const ok = await loadCat(cat);
  if (!ok) return;
  const idx = draw(cat);
  const src = playlists.get(cat)[idx];
  playPath(cat, src);
  updateProgress();
}

async function playPrev(cat) {
  const ok = await loadCat(cat);
  if (!ok) return;
  const idx = drawPrev(cat);
  const src = playlists.get(cat)[idx];
  playPath(cat, src);
  updateProgress();
}

/* =======================
   EVENTS
   ======================= */

document.getElementById("enterBtn").addEventListener("click", () => {
  setStatus("Avvio‚Ä¶");
  introAudio.currentTime = 0;
  introAudio.play().catch(() => {});
  bg.style.backgroundImage =
    `radial-gradient(1200px 700px at 50% 70%, rgba(0,255,154,.12), transparent 60%),
     radial-gradient(900px 500px at 50% 40%, rgba(0,255,154,.10), transparent 60%),
     url("assets/inizio.jpeg") center/cover no-repeat`;
  show("pills");
  setStatus("Pronto.");
});

document.getElementById("blueBtn").addEventListener("click", () => {
  introAudio.pause();
  window.open(ANSA_URL, "_blank", "noopener,noreferrer");
});

document.getElementById("redBtn").addEventListener("click", () => {
  introAudio.pause();
  show("menu");
  setStatus("Menu.");
  
  // Mostra badge per categorie gi√† caricate
  updateNewBadges();
  
  // Carica progressivamente le categorie NON ancora caricate in background
  setTimeout(() => {
    loadCategoriesInBackground();
  }, 500);
});

document.getElementById("backToPills").addEventListener("click", () => {
  show("pills");
  setStatus("Pronto.");
});

document.querySelectorAll(".menuBtn[data-cat]").forEach(b => {
  b.addEventListener("click", () => playNext(b.dataset.cat));
});

document.getElementById("prevBtn").addEventListener("click", () => {
  playPrev(currentCat);
});

document.getElementById("nextBtn").addEventListener("click", () => {
  playNext(currentCat);
});

shuffleBtn.addEventListener("click", () => {
  shuffleMode = !shuffleMode;
  shuffleBtn.classList.toggle("active", shuffleMode);
  resetDeck(currentCat);
  setStatus(shuffleMode ? "Casuale ON" : "Casuale OFF");
});
shuffleBtn.classList.add("active");

document.getElementById("stopBtn").addEventListener("click", () => {
  audio.pause();
  audio.src = "";
  video.pause();
  video.src = "";
  
  if (document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement) {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if (document.webkitExitFullscreen) {
      document.webkitExitFullscreen();
    } else if (document.mozCancelFullScreen) {
      document.mozCancelFullScreen();
    }
  }
  
  showPlayer(false);
  show("menu");
  setStatus("Menu.");
});

audio.addEventListener("ended", () => playNext(currentCat));
video.addEventListener("ended", () => playNext(currentCat));

audio.addEventListener("timeupdate", updateTime);
video.addEventListener("timeupdate", updateTime);

/* =======================
   ORACLE SYSTEM
   ======================= */

// Elementi DOM Oracle
const oracleChat = document.getElementById("oracleChat");
const micBtn = document.getElementById("micBtn");

const kbWrap = document.getElementById("kbWrap");
const kbInput = document.getElementById("kbInput");
const kbSend = document.getElementById("kbSend");
const clearChatBtn = document.getElementById("clearChatBtn");
const backFromOracle = document.getElementById("backFromOracle");
const ochoBtn = document.getElementById("ochoBtn");

// Crea stelline magiche sul pulsante OCHO
function createSparkles() {
  const button = ochoBtn;
  if (!button) return;
  
  setInterval(() => {
    const sparkle = document.createElement('div');
    sparkle.className = 'sparkle';
    
    // Posizione casuale attorno al pulsante
    const angle = Math.random() * 360;
    const distance = 30 + Math.random() * 20;
    const x = Math.cos(angle * Math.PI / 180) * distance;
    const y = Math.sin(angle * Math.PI / 180) * distance;
    
    sparkle.style.left = `calc(50% + ${x}px)`;
    sparkle.style.top = `calc(50% + ${y}px)`;
    sparkle.style.animationDelay = Math.random() * 2 + 's';
    
    button.appendChild(sparkle);
    
    // Rimuovi dopo l'animazione
    setTimeout(() => sparkle.remove(), 2000);
  }, 300);
}

// Inizializza il riconoscimento vocale (lazy loading)
function initSpeechRecognition() {
  if (recognition) return; // Gi√† inizializzato
  
  if ('webkitSpeechRecognition' in window || 'SpeechRecognition' in window) {
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    recognition = new SpeechRecognition();
    recognition.lang = 'it-IT';
    recognition.continuous = false;
    recognition.interimResults = false;
    
    } else {
    }
}

// Carica la biblioteca dalla cartella libreria/
async function loadLibrary() {
  if (libraryLoaded) return;
  
  try {
    const url = `https://api.github.com/repos/${GITHUB_USER}/${GITHUB_REPO}/contents/libreria?ref=${GITHUB_BRANCH}`;
    const res = await fetch(url);
    
    if (!res.ok) {
      libraryLoaded = true;
      return;
    }
    
    const files = await res.json();
    const txtFiles = files.filter(f => f.name.endsWith('.txt'));
    
    for (const file of txtFiles) {
      const contentRes = await fetch(file.download_url);
      const content = await contentRes.text();
      libraryTexts.push({
        filename: file.name,
        content: content
      });
    }
    
    libraryLoaded = true;
    
  } catch (error) {
    console.error('Errore caricamento libreria:', error);
    libraryLoaded = true;
  }
}

// Aggiungi messaggio alla chat (con effetto macchina da scrivere per OCHO)
function typewriter(el, text, speedMs = 18) {
  return new Promise((resolve) => {
    el.textContent = "";
    el.classList.add("typing");
    let i = 0;
    const timer = setInterval(() => {
      el.textContent += text.charAt(i);
      i++;
      oracleChat.scrollTop = oracleChat.scrollHeight;
      if (i >= text.length) {
        clearInterval(timer);
        el.classList.remove("typing");
        resolve();
      }
    }, speedMs);
    // salva timer per poterlo fermare su "Pulisci Chat"
    el.dataset.timerId = String(timer);
  });
}

function stopAllTyping() {
  oracleChat.querySelectorAll(".message.typing").forEach(m => {
    const tid = Number(m.dataset.timerId || 0);
    if (tid) clearInterval(tid);
    m.classList.remove("typing");
  });
}

// Aggiungi messaggio alla chat
function addMessage(text, type = 'oracle') {
  const msg = document.createElement('div');
  msg.className = `message ${type}`;
  oracleChat.appendChild(msg);
  oracleChat.scrollTop = oracleChat.scrollHeight;

  if (type === 'oracle') {
    return typewriter(msg, text, 16);
  } else {
    msg.textContent = text;
    return Promise.resolve();
  }
}

function addSystemMessage(text){ return; }

// Chiedi a Claude (Anthropic API)
// --- RICERCA NELL'ARCHIVIO (semplice ma efficace) ---
const IT_STOP = new Set([
  "a","ad","al","allo","alla","alle","agli","ai","anche","anzi","avere","che","chi","ci","coi","come","con","contro",
  "cui","da","dal","dallo","dalla","dalle","dagli","dei","del","dell","della","delle","degli","di","dove","due","e",
  "√®","ed","era","ero","essere","fa","fai","fanno","gli","ha","hai","hanno","ho","i","il","in","io","la","le","lei",
  "lo","loro","lui","ma","mi","mia","mie","miei","molto","ne","nei","nel","nell","nella","nelle","no","noi","non",
  "o","oggi","ogni","per","perch√©","pero","pi√π","poi","quale","quando","quanto","qui","quindi","se","sei","si",
  "sia","sono","su","sul","sulla","tra","tre","tu","tua","un","una","uno","vi","voi"
]);


const metaphysicalHints = [
  "dio","morte","aldil√†","anima","assoluto","verit√†","senso della vita","coscienza universale","chi sono","perch√© esisto"
];
function isMetaphysical(q){
  const low = (q||"").toLowerCase();
  return metaphysicalHints.some(k => low.includes(k));
}

function noGroqRephrase(q, contexts, isRetry){
  // Mini-riformulazione locale (senza LLM): rende risposta pi√π "OCHO" e meno copia-incolla.
  const pick = (i) => (contexts[i]?.text || "").split(/\n+/).map(x=>x.trim()).filter(Boolean)[0] || "";
  let a = pick(0);
  let b = pick(1);

  // Se retry e c'√® un secondo contesto, fondi due spunti
  let core = (isRetry && b) ? (a + " " + b) : a;

  // Pulizia veloce
  core = core.replace(/\s+/g," ").trim();
  if (!core) core = "Questo non √® nel mio archivio.";

  // Voce OCHO
  const intro = isRetry ? "Ti rispondo in modo pi√π preciso: " : "Io la vedo cos√¨: ";
  // Taglio
  if (core.length > 360) core = core.slice(0, 360).trim() + "‚Ä¶";
  return intro + core;
}


function normTokens(s) {
  return (s || "")
    .toLowerCase()
    .replace(/[^a-z√†√®√©√¨√≤√≥√π0-9\s]/g, " ")
    .split(/\s+/)
    .filter(t => t && t.length > 2 && !IT_STOP.has(t));
}

function cosineSim(aMap, bMap) {
  let dot = 0, a2 = 0, b2 = 0;
  for (const [k, av] of aMap.entries()) {
    a2 += av*av;
    const bv = bMap.get(k) || 0;
    dot += av*bv;
  }
  for (const bv of bMap.values()) b2 += bv*bv;
  if (!a2 || !b2) return 0;
  return dot / (Math.sqrt(a2) * Math.sqrt(b2));
}



function isDissatisfied(q){
  const low = (q||"").toLowerCase();
  return ["spiegami meglio","non ho capito","pi√π preciso","pi√π chiaro","non cos√¨","intendevo","no","non va bene","ancora"].some(k => low.includes(k));
}

function questionSimilarity(a, b) {
  const ta = new Set(normTokens(a));
  const tb = new Set(normTokens(b));
  if (!ta.size || !tb.size) return 0;
  let inter = 0;
  for (const t of ta) if (tb.has(t)) inter++;
  const union = ta.size + tb.size - inter;
  return union ? (inter / union) : 0;
}

function tfMap(tokens) {
  const m = new Map();
  tokens.forEach(t => m.set(t, (m.get(t)||0) + 1));
  return m;
}

function chunkText(text, maxLen=700) {
  const parts = [];
  const paras = (text || "").split(/\n\s*\n/).map(p => p.trim()).filter(Boolean);
  let buf = "";
  for (const p of paras) {
    if ((buf + "\n\n" + p).length > maxLen) {
      if (buf) parts.push(buf);
      buf = p;
    } else {
      buf = buf ? (buf + "\n\n" + p) : p;
    }
  }
  if (buf) parts.push(buf);
  return parts.length ? parts : [text];
}

function buildPassages() {
  const passages = [];
  for (const doc of libraryTexts) {
    const chunks = chunkText(doc.content, 700);
    chunks.forEach((c, idx) => {
      const tokens = normTokens(c);
      passages.push({
        id: `${doc.filename}#${idx}`,
        filename: doc.filename,
        text: c,
        vec: tfMap(tokens)
      });
    });
  }
  return passages;
}

let passagesCache = null;
let lastUserQuestion = '';
let lastOracleAnswer = '';
let retryCount = 0;


function retrievePassages(question, k=3) {
  if (!libraryTexts.length) return [];
  if (!passagesCache) passagesCache = buildPassages();
  const qVec = tfMap(normTokens(question));
  const scored = passagesCache.map(p => ({...p, score: cosineSim(qVec, p.vec)}));
  scored.sort((a,b) => b.score - a.score);
  return scored.slice(0, k).filter(x => x.score > 0.05);
}

// Chiedi a Groq (opzionale) con contesto ridotto (RAG)
async function askGroqWithContext(question, contexts, opts = {}) {
  const contextBlock = contexts.map((c, i) => `CONTESTO ${i+1}:\n${c.text}`).join("\n\n---\n\n");

  const systemBase = `Sei OCHO. Rispondi SEMPRE in prima persona, come se queste idee fossero tue.
Regole obbligatorie:
- Non citare MAI autori, fonti, documenti o "secondo X".
- Non usare frasi tipo: "la fonte dice", "secondo l'autore", "nel testo si legge".
- Non riportare nomi propri presenti nel contesto come attribuzione.
- Tono diretto e assertivo: "Io...", "Per me...", "Ti rispondo cos√¨...".
- Usa SOLO i contesti forniti (non inventare).
- Parafrasa SEMPRE: non copiare frasi lunghe dal contesto; riscrivi con parole tue mantenendo il senso.
- Se i contesti non bastano, d√¨: "Questo non √® nel mio archivio." (senza inventare).`;

  const modeRules = `Modalit√† C (Oracolo / Silenzio):
- Se la domanda √® troppo assoluta/metafisica o chiede verit√† ultime (es: "dimmi la verit√† definitiva", "cosa c'√® dopo la morte", "dimostrami Dio"), rispondi in modalit√† SILENZIO: 1‚Äì2 frasi, enigmatiche e non dogmatiche, oppure una sola frase: "Non √® qualcosa che posso dire con parole."
- Se la domanda √® pratica o chiede chiarimenti, rispondi in modalit√† ORACOLO: 3‚Äì6 frasi, pi√π esplicite.
- Se la domanda chiede definizioni operative ("cosa intendi per..."), ORACOLO con un esempio breve.`;

  const retryRules = `Se l'utente riformula la stessa domanda perch√© non √® soddisfatto, rendi la risposta pi√π precisa:
- Chiarisci termini.
- Vai pi√π "a terra" con un esempio o una distinzione.
- Aumenta leggermente i dettagli (fino a 7 frasi), senza diventare prolisso.
- Non ripetere identica la risposta precedente.
- Cambia formulazione: riscrivi in modo diverso (parole, struttura, esempio) mantenendo coerenza.`;

  const isRetry = !!opts.isRetry;
  const prev = (opts.prevAnswer || "").trim();
  const prevBlock = prev ? `\n\nRISPOSTA PRECEDENTE (da non ripetere uguale):\n${prev}` : "";
  const system = `${systemBase}\n\n${modeRules}\n\n${retryRules}${prevBlock}`;

  const maxTokens = isRetry ? 520 : 320;
  const temperature = isRetry ? 0.55 : 0.35;

  const res = await fetch("https://api.groq.com/openai/v1/chat/completions", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "Authorization": `Bearer ${GROQ_API_KEY}`
    },
    body: JSON.stringify({
      model: GROQ_MODEL,
      temperature: temperature,
      max_tokens: maxTokens,
      messages: [
        { role: "system", content: system + "\n\n" + contextBlock },
        { role: "user", content: question }
      ]
    })
  });

  if (!res.ok) throw new Error(`Groq API Error: ${res.status}`);
  const data = await res.json();
  return data.choices?.[0]?.message?.content?.trim() || "";
}

// Chiedi a OCHO (retrieval + eventuale modello)
async function askOracle(question) {
  if (!question || question.trim() === '') return;

  await addMessage(question, 'user');
  const prevQ = lastUserQuestion;
  lastUserQuestion = question;

  if (!libraryLoaded) {
    await loadLibrary();
  }

  const sim = questionSimilarity(question, lastUserQuestion);
  const isRetry = (sim >= 0.45) || isDissatisfied(question);
  retryCount = isRetry ? Math.min(retryCount + 1, 3) : 0;
  const k = isRetry ? 5 : 3;
  const contexts = retrievePassages(question, k);

  // Rimuovi il messaggio "cerca..."
  const loadingMsg = oracleChat.querySelector('.message.system:last-child');
  if (loadingMsg && loadingMsg.textContent.includes('cerca')) loadingMsg.remove();

  if (!contexts.length) {
    const answer = "Questo non √® nel mio archivio.";
    await addMessage(answer, 'oracle');
    return;
  }

  // Se NON hai Groq key: risposta 100% archivio
  if (!GROQ_API_KEY) {
    let best = contexts[0].text.trim();
    if (best.length > 500) best = best.slice(0, 500).trim() + "‚Ä¶";

    if (isMetaphysical(question)) {
      const firstLine = best.split(/\n+/).map(x=>x.trim()).filter(Boolean)[0] || "";
      best = firstLine ? firstLine : "Non √® qualcosa che posso dire con parole.";
    }
    best = noGroqRephrase(question, contexts, isRetry);
    lastOracleAnswer = best;
    await addMessage(best, 'oracle');
    return;
  }

  // Se hai Groq key: risposta breve basata sui contesti
  try {
    const answer = await askGroqWithContext(question, contexts, { isRetry, prevAnswer: lastOracleAnswer });
    const lm = oracleChat.querySelector('.message.system:last-child');
    if (lm && lm.textContent.includes('elabora')) lm.remove();

    const finalAnswer = answer || "Questo non √® nel mio archivio.";
    await addMessage(finalAnswer, 'oracle');
  } catch (error) {
    console.error('Errore Groq:', error);
    let best = contexts[0].text.trim();
    if (best.length > 500) best = best.slice(0, 500).trim() + "‚Ä¶";
    best = noGroqRephrase(question, contexts, isRetry);
    lastOracleAnswer = best;
    await addMessage(best, 'oracle');
  }
}

// Voce (TTS) disattivata: OCHO risponde solo in chat.
async function speakWithJack(text) {
  return;
}

// Avvia l'ascolto
function startListening() {
  initSpeechRecognition(); // Inizializza solo ora
  
  if (!recognition) {
    return;
  }
  
  isListening = true;
  micBtn.classList.add('listening');
  recognition.onresult = (event) => {
    const transcript = event.results[0][0].transcript;
    stopListening();
    askOracle(transcript);
  };
  
  recognition.onerror = (event) => {
    console.error('Speech recognition error:', event.error);
    stopListening();
    };
  
  recognition.onend = () => {
    if (isListening) {
      stopListening();
    }
  };
  
  recognition.start();
}

// Ferma l'ascolto
function stopListening() {
  isListening = false;
  micBtn.classList.remove('listening');
  if (recognition) {
    recognition.stop();
  }
}

// Event Listeners Oracle
ochoBtn.addEventListener("click", () => {
  show("oracle");
  setStatus("OCHO attivo");
  if (!libraryLoaded) {
    loadLibrary();
  }
});

backFromOracle.addEventListener("click", () => {
  show("menu");
  setStatus("Menu");
  if (isListening) {
    stopListening();
  }
});


function enableKeyboardMode(reasonText) {
  if (kbWrap) kbWrap.classList.remove("hidden");
  if (reasonText) if (kbInput) {
    kbInput.focus();
    kbInput.select();
  }
}
function disableKeyboardMode() {
  if (kbWrap) kbWrap.classList.add("hidden");
}

micBtn.addEventListener("click", () => {
  if (isListening) {
    stopListening();
  } else {
    startListening();
  }
});
// Invio da tastiera
if (kbSend) {
  kbSend.addEventListener('click', async () => {
    const q = (kbInput?.value || '').trim();
    if (!q) return;
    kbInput.value = '';
    await askOracle(q);
  });
}
if (kbInput) {
  kbInput.addEventListener('keydown', async (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      const q = (kbInput.value || '').trim();
      if (!q) return;
      kbInput.value = '';
      await askOracle(q);
    }
  });
}


clearChatBtn.addEventListener("click", () => {
  oracleChat.innerHTML = '<div class="message system">üåå Chat pulita. OCHO pronto.</div>';
});

// Inizializza stelline magiche
createSparkles();

/* BOOT */
show("enter");
setStatus("In attesa‚Ä¶");

console.log("üöÄ OCHO con Auto-Detection NEW OTTIMIZZATO!");
console.log(`üìÖ File NEW = scoperti negli ultimi ${NEW_FILE_DAYS} giorni`);
console.log("‚ö° Caricamento ON-DEMAND (no rate limiting!)");
console.log("üìä Categorie tracciate:", Object.keys(fileSnapshots).length);
</script>
</body>
</html>

